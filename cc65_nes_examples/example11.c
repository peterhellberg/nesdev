//this example is just examples 2 and 10 combined together,
//to show how much of action a C program on the NES can have
//it tops the CPU time, just fits it to keep up steady 60 FPS
//various optimizations of C code are still possible


#include "neslib.h"



static unsigned char update_list[3+32+3+8+1];//3 bytes address and length for 32 tiles, 3 bytes address and length for 8 attributes, end marker


//these macro are needed to simplify defining update list constants

#define NTADR(x,y)	((NAMETABLE_A|((y)<<5)|x))

#define MSB(x)		(((x)>>8))
#define LSB(x)		(((x)&0xff))

//metatile palettes

#define BGPAL0	0x00	//bin 00000000
#define BGPAL1	0x55	//bin 01010101
#define BGPAL2	0xaa	//bin 10101010
#define BGPAL3	0xff	//bin 11111111

//metatile definitions, one metatile by another, 4 bytes per metatile

const unsigned char metatiles[]={
	0x00,0x00,0x00,0x00,
	0x80,0x81,0x90,0x91,
	0x82,0x83,0x92,0x93,
	0x84,0x85,0x94,0x95,
	0x86,0x87,0x96,0x97
};

//metatile attributes, define which palette should be used for a metatile

const unsigned char metaattrs[]={
	BGPAL0,
	BGPAL0,
	BGPAL1,
	BGPAL2,
	BGPAL3
};

//total number of balls on the screen
//since there are 64 HW sprites, and one is controlled by the player, it is absolute max

#define BALLS_MAX	63

//balls parameters

static unsigned char ball_x[BALLS_MAX];
static unsigned char ball_y[BALLS_MAX];
static unsigned char ball_dx[BALLS_MAX];
static unsigned char ball_dy[BALLS_MAX];

//palette data

const unsigned char palBackground[16]={ 0x0f,0x16,0x26,0x36,0x0f,0x18,0x28,0x38,0x0f,0x19,0x29,0x39,0x0f,0x1c,0x2c,0x3c };
const unsigned char palSprites   [16]={ 0x0f,0x17,0x27,0x37,0x0f,0x11,0x21,0x31,0x0f,0x15,0x25,0x35,0x0f,0x19,0x29,0x39 };

//level data, it is upside down to make it easier to access

const unsigned char level_data[]={
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,
	0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,
	0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,
	0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x03,0x03,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x03,0x03,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x04,0x04,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x04,0x04,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,
	0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,
	0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,
	0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,0x00,0x00,
	0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,
	0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,
	0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,
	0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,
	0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,0x00,
	0x00,0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,
	0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,
	0x00,0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,
	0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,
	0x00,0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,
	0x00,0x00,0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,
	0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,
	0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,
	0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,
	0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,0x00,
	0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,
	0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,
	0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,
	0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,
	0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,
	0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,
	0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x00,
	0x00,0x00,0x03,0x00,0x03,0x04,0x03,0x00,0x03,0x00,0x03,0x04,0x03,0x00,0x00,0x00,
	0x00,0x00,0x00,0x02,0x04,0x02,0x04,0x02,0x00,0x02,0x04,0x02,0x04,0x02,0x00,0x00,
	0x00,0x00,0x02,0x04,0x02,0x00,0x02,0x04,0x02,0x04,0x02,0x00,0x02,0x04,0x00,0x00,
	0x00,0x00,0x04,0x01,0x00,0x01,0x00,0x01,0x04,0x01,0x00,0x01,0x00,0x01,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x02,0x02,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0x02,0x00,0x03,0x03,0x03,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,
	0x00,0x00,0x01,0x01,0x01,0x00,0x02,0x02,0x02,0x00,0x03,0x03,0x03,0x00,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02
};

//calculate height of the level in pixels

#define LEVEL_HEIGHT	(sizeof(level_data)/16*16)



//all variables were made global and moved into zeropage to avoid CPU usage peaks
//that caused occasional lag frames in this example (happened when many balls touch an edge)

#pragma bssseg (push,"ZEROPAGE")
#pragma dataseg(push,"ZEROPAGE")

static unsigned char col,tile,attr,tile_off,updn_off,upda_off,mask1,mask2,mask3,mask4;
static unsigned char i,j,spr;
static unsigned int name_adr,attr_adr;
static const unsigned char *src;



//this function prepares data for a row update
//also used to fill the screen before scrolling starts
	
	
	
void prepare_row_update(unsigned char name_row,unsigned int level_row)
{
	if(name_row<30)//calculate tile and attribute row addresses in a nametable
	{
		name_adr=NAMETABLE_A+(name_row<<5);
		attr_adr=NAMETABLE_A+960+((name_row>>2)<<3);
	}
	else
	{
		name_row-=30;

		name_adr=NAMETABLE_C+(name_row<<5);
		attr_adr=NAMETABLE_C+960+((name_row>>2)<<3);
	}

	update_list[0]=MSB(name_adr)|NT_UPD_HORZ;//set nametable update address
	update_list[1]=LSB(name_adr);

	update_list[35]=MSB(attr_adr)|NT_UPD_HORZ;//set attribute table update address
	update_list[36]=LSB(attr_adr);

	updn_off=3;//offset in the update list for nametable data
	upda_off=3+32+3;//offset for attribute data

	src=&level_data[level_row<<4];//get offset in the level data

	if(!(name_row&1)) tile_off=0; else tile_off=2;//metatile data offset, 2 for odd row numbers

	if(!(name_row&2))//select appropriate masks for attribute bytes
	{
		mask1=0xfc;
		mask2=0x03;
		mask3=0xf3;
		mask4=0x0c;
	}
	else
	{
		mask1=0xcf;
		mask2=0x30;
		mask3=0x3f;
		mask4=0xc0;
	}

	for(col=0;col<8;++col)//as two neighborn attributes are grouped into a byte, the loop handles two metatiles in one iteration
	{
		tile=*src++;//get first metatile code

		attr=(update_list[upda_off]&mask1)|(metaattrs[tile]&mask2);//get metatile attribute, remember it

		tile=(tile<<2)+tile_off;//get metatile offset

		update_list[updn_off+0]=metatiles[tile+0];//put top or bottom half of the first metatile into the update buffer
		update_list[updn_off+1]=metatiles[tile+1];

		tile=*src++;//get second metatile code

		update_list[upda_off++]=(attr&mask3)|(metaattrs[tile]&mask4);//get attribute, add the other attribute, put into update buffer

		tile=(tile<<2)+tile_off;//get metatile offset

		update_list[updn_off+2]=metatiles[tile+0];//put top or bottom half of the second metatile into the update buffer
		update_list[updn_off+3]=metatiles[tile+1];

		updn_off+=4;
	}
}



//fill the whole screen with actual level graphics
//it uses the prepare_row function, but copies the data into VRAM using
//flush_vram_update instead of the update system (would take 30 frames otherwise)

void preload_screen(unsigned int level_y)
{
	static unsigned char i;

	for(i=0;i<30;++i)
	{
		prepare_row_update(29-i,level_y>>4);//prepare a row, bottom to top

		flush_vram_update(update_list);

		level_y+=8;
	}
}



//get metatile code for given x,y level position in pixels, relative to current offset in the level
//funciton like this could be used for collision detection purposes

unsigned char get_metatile(int level_y,unsigned int x,unsigned int y)
{
	level_y=level_y-240+(240-y);//the level is stored upside down, flip the axis

	if(level_y<0) level_y+=LEVEL_HEIGHT;//loop the level to avoid reading outside the level data

	return level_data[((level_y>>4)<<4)|(x>>4)];//level_y/16 is pixels to row, then *16 is row to offset, then x/16 is pixels to column
}



void balls_init(void)
{
	for(i=0;i<BALLS_MAX;++i)
	{
		//starting coordinates

		ball_x[i]=rand8();
		ball_y[i]=rand8();

		//direction bits

		j=rand8();

		//horizontal speed -3..-3, excluding 0
		spr=1+(rand8()%3);
		ball_dx[i]=j&1?-spr:spr;

		//vertical speed

		spr=1+(rand8()%3);
		ball_dy[i]=j&2?-spr:spr;
	}
}



void balls_update(void)
{
	spr=0;

	for(i=0;i<BALLS_MAX;++i)
	{
		//set a sprite for current ball

		spr=oam_spr(ball_x[i],ball_y[i],0x40,i&3,spr);//0x40 is tile number, i&3 is palette

		//move the ball

		ball_x[i]+=ball_dx[i];
		ball_y[i]+=ball_dy[i];

		//bounce the ball off the edges

		if(ball_x[i]>=(256-8)) ball_dx[i]=-ball_dx[i];
		if(ball_y[i]>=(240-8)) ball_dy[i]=-ball_dy[i];
	}
}



//main function, program starts here

void main(void)
{
	static unsigned char pad,tile,name_row,sprite_x,sprite_y;
	static unsigned int level_y;
	static int scroll_y;

	pal_bg(palBackground);//set background palette from an array
	pal_spr(palSprites);//set palette for sprites

	update_list[0]=0x20|NT_UPD_HORZ;//horizontal update sequence, dummy address
	update_list[1]=0x00;
	update_list[2]=32;//length of nametable update sequence

	update_list[35]=0x20|NT_UPD_HORZ;
	update_list[36]=0x00;
	update_list[37]=8;//length of attribute update sequence

	update_list[46]=NT_UPD_EOF;

	preload_screen(0);//fill the whole screen with beginning of the level

	level_y=8*30;//30 lines were already preloaded, advance the level offset
	scroll_y=0;//screen scroll value, it loops in range of 0..479 (240*2-1)

	sprite_x=128;
	sprite_y=120;

	balls_init();
	
	ppu_on_all();//enable rendering

	delay(60);//delay to show the preloaded part of the level

	while(1)
	{
		ppu_wait_nmi();

		*(unsigned char*)0x401e=0;
		
		set_vram_update(NULL);//disable update just in case, not really needed in this example

		if(!(level_y&7))//put new row every 8 pixels
		{
			name_row=(scroll_y>>3)+59;//update row just above the visible part of the screen

			if(name_row>=60) name_row-=60;//keep the row number within the limits

			prepare_row_update(name_row,level_y>>4);

			set_vram_update(update_list);//the update is handled at next NMI
		}

		scroll(0,scroll_y);//scroll value will be applied on the next nmi as well

		++level_y;

		if(level_y>=LEVEL_HEIGHT) level_y=0;//loop the level

		--scroll_y;

		if(scroll_y<0) scroll_y=240*2-1;//keep Y within the total height of two nametables



		//this part demonstrates how BG collision detection could be done

		tile=get_metatile(level_y,sprite_x,sprite_y);//get metatile number from the level

		if(!tile) tile=0x1f; else tile+=0x20;//? for tile 0, ABCD for tiles 1,2,3,4

		oam_spr(sprite_x-4,sprite_y-4,tile,0,63*4);//display sprite

		pad=pad_poll(0);//move the sprite around

		if(pad&PAD_LEFT)  if(sprite_x>4)   sprite_x-=2;
		if(pad&PAD_RIGHT) if(sprite_x<252) sprite_x+=2;
		if(pad&PAD_UP)    if(sprite_y>4)   sprite_y-=2;
		if(pad&PAD_DOWN)  if(sprite_y<236) sprite_y+=2;
		
		balls_update();
		
		*(unsigned char*)0x401f=0;
	}
}
