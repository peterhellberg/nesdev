//this example shows non-looped vertical scroll, with 2x2 metatiles and attributes
//it is close enough to one that would be needed in an actual game
//horizontal mirroring (gives 32x60 nametable layout) is used to hide the changing row
//this example uses about 20% of CPU time

#include "neslib.h"



static unsigned char update_list[3+32+3+8+1];//3 bytes address and length for 32 tiles, 3 bytes address and length for 8 attributes, end marker

//palette data

const unsigned char palette[16]={ 0x0f,0x16,0x26,0x36,0x0f,0x18,0x28,0x38,0x0f,0x19,0x29,0x39,0x0f,0x1c,0x2c,0x3c };

//metatile palettes

#define BGPAL0	0x00	//bin 00000000
#define BGPAL1	0x55	//bin 01010101
#define BGPAL2	0xaa	//bin 10101010
#define BGPAL3	0xff	//bin 11111111

//metatile definitions, one metatile by another, 4 bytes per metatile

const unsigned char metatiles[]={
	0x00,0x00,0x00,0x00,
	0x80,0x81,0x90,0x91,
	0x82,0x83,0x92,0x93,
	0x84,0x85,0x94,0x95,
	0x86,0x87,0x96,0x97
};

//metatile attributes, define which palette should be used for a metatile

const unsigned char metaattrs[]={
	BGPAL0,
	BGPAL0,
	BGPAL1,
	BGPAL2,
	BGPAL3
};

//level data, it is upside down to make it easier to access

const unsigned char level_data[]={
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,
	0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,
	0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,
	0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x03,0x03,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x03,0x03,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x04,0x04,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x04,0x04,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,
	0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,
	0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,
	0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,0x00,0x00,
	0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,
	0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,
	0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,
	0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00,
	0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,0x00,
	0x00,0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,
	0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,
	0x00,0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,
	0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,0x00,
	0x00,0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,
	0x00,0x00,0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,0x00,
	0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,
	0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,
	0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,
	0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,0x00,
	0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,0x00,
	0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,
	0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,
	0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,
	0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x02,0x00,0x03,0x00,0x00,0x04,0x00,0x04,
	0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x04,0x00,0x04,
	0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x00,
	0x00,0x00,0x03,0x00,0x03,0x04,0x03,0x00,0x03,0x00,0x03,0x04,0x03,0x00,0x00,0x00,
	0x00,0x00,0x00,0x02,0x04,0x02,0x04,0x02,0x00,0x02,0x04,0x02,0x04,0x02,0x00,0x00,
	0x00,0x00,0x02,0x04,0x02,0x00,0x02,0x04,0x02,0x04,0x02,0x00,0x02,0x04,0x00,0x00,
	0x00,0x00,0x04,0x01,0x00,0x01,0x00,0x01,0x04,0x01,0x00,0x01,0x00,0x01,0x00,0x00,
	0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,
	0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x02,0x02,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0x02,0x00,0x03,0x03,0x03,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,
	0x00,0x00,0x01,0x01,0x01,0x00,0x02,0x02,0x02,0x00,0x03,0x03,0x03,0x00,0x00,0x00,
	0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,
	0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02
};

//calculate height of the level in pixels

#define LEVEL_HEIGHT	(sizeof(level_data)/16*16)



//this function prepares data for a row update
//also used to fill the screen before scrolling starts

void prepare_row_update(unsigned char name_row,unsigned int level_row)
{
	static unsigned char i,tile,attr,tile_off,updn_off,upda_off,mask1,mask2,mask3,mask4;
	static unsigned int name_adr,attr_adr;
	static const unsigned char *src;

	if(name_row<30)//calculate tile and attribute row addresses in a nametable
	{
		name_adr=NAMETABLE_A+(name_row<<5);
		attr_adr=NAMETABLE_A+960+((name_row>>2)<<3);
	}
	else
	{
		name_row-=30;

		name_adr=NAMETABLE_C+(name_row<<5);
		attr_adr=NAMETABLE_C+960+((name_row>>2)<<3);
	}

	update_list[0]=MSB(name_adr)|NT_UPD_HORZ;//set nametable update address
	update_list[1]=LSB(name_adr);

	update_list[35]=MSB(attr_adr)|NT_UPD_HORZ;//set attribute table update address
	update_list[36]=LSB(attr_adr);

	updn_off=3;//offset in the update list for nametable data
	upda_off=3+32+3;//offset for attribute data

	src=&level_data[level_row<<4];//get offset in the level data

	if(!(name_row&1)) tile_off=0; else tile_off=2;//metatile data offset, 2 for odd row numbers

	if(!(name_row&2))//select appropriate masks for attribute bytes
	{
		mask1=0xfc;
		mask2=0x03;
		mask3=0xf3;
		mask4=0x0c;
	}
	else
	{
		mask1=0xcf;
		mask2=0x30;
		mask3=0x3f;
		mask4=0xc0;
	}

	for(i=0;i<8;++i)//as two neighborn attributes are grouped into a byte, the loop handles two metatiles in one iteration
	{
		tile=*src++;//get first metatile code

		attr=(update_list[upda_off]&mask1)|(metaattrs[tile]&mask2);//get metatile attribute, remember it

		tile=(tile<<2)+tile_off;//get metatile offset

		update_list[updn_off+0]=metatiles[tile+0];//put top or bottom half of the first metatile into the update buffer
		update_list[updn_off+1]=metatiles[tile+1];

		tile=*src++;//get second metatile code

		update_list[upda_off++]=(attr&mask3)|(metaattrs[tile]&mask4);//get attribute, add the other attribute, put into update buffer

		tile=(tile<<2)+tile_off;//get metatile offset

		update_list[updn_off+2]=metatiles[tile+0];//put top or bottom half of the second metatile into the update buffer
		update_list[updn_off+3]=metatiles[tile+1];

		updn_off+=4;
	}
}



//fill the whole screen with actual level graphics
//it uses the prepare_row function, but copies the data into VRAM using
//flush_vram_update instead of the update system (would take 30 frames otherwise)

void preload_screen(unsigned int level_y)
{
	static unsigned char i;

	for(i=0;i<30;++i)
	{
		prepare_row_update(29-i,level_y>>4);//prepare a row, bottom to top

		flush_vram_update(update_list);

		level_y+=8;
	}
}



//get metatile code for given x,y level position in pixels, relative to current offset in the level
//funciton like this could be used for collision detection purposes

unsigned char get_metatile(int level_y,unsigned int x,unsigned int y)
{
	level_y=level_y-240+(240-y);//the level is stored upside down, flip the axis

	if(level_y<0) level_y+=LEVEL_HEIGHT;//loop the level to avoid reading outside the level data

	return level_data[((level_y>>4)<<4)|(x>>4)];//level_y/16 is pixels to row, then *16 is row to offset, then x/16 is pixels to column
}



//main function, program starts here

void main(void)
{
	static unsigned char pad,tile,name_row,sprite_x,sprite_y;
	static unsigned int level_y;
	static int scroll_y;

	pal_bg(palette);//set background palette from an array
	pal_col(17,0x30);//white color for sprite

	update_list[0]=0x20|NT_UPD_HORZ;//horizontal update sequence, dummy address
	update_list[1]=0x00;
	update_list[2]=32;//length of nametable update sequence

	update_list[35]=0x20|NT_UPD_HORZ;
	update_list[36]=0x00;
	update_list[37]=8;//length of attribute update sequence

	update_list[46]=NT_UPD_EOF;

	preload_screen(0);//fill the whole screen with beginning of the level

	level_y=8*30;//30 lines were already preloaded, advance the level offset
	scroll_y=0;//screen scroll value, it loops in range of 0..479 (240*2-1)

	sprite_x=128;
	sprite_y=120;

	ppu_on_all();//enable rendering

	delay(60);//delay to show the preloaded part of the level

	while(1)
	{
		ppu_wait_nmi();

		set_vram_update(NULL);//disable update just in case, not really needed in this example

		if(!(level_y&7))//put new row every 8 pixels
		{
			name_row=(scroll_y>>3)+59;//update row just above the visible part of the screen

			if(name_row>=60) name_row-=60;//keep the row number within the limits

			prepare_row_update(name_row,level_y>>4);

			set_vram_update(update_list);//the update is handled at next NMI
		}

		scroll(0,scroll_y);//scroll value will be applied on the next nmi as well

		++level_y;

		if(level_y>=LEVEL_HEIGHT) level_y=0;//loop the level

		--scroll_y;

		if(scroll_y<0) scroll_y=240*2-1;//keep Y within the total height of two nametables



		//this part demonstrates how BG collision detection could be done

		tile=get_metatile(level_y,sprite_x,sprite_y);//get metatile number from the level

		if(!tile) tile=0x1f; else tile+=0x20;//? for tile 0, ABCD for tiles 1,2,3,4

		oam_spr(sprite_x-4,sprite_y-4,tile,0,0);//display sprite

		pad=pad_poll(0);//move the sprite around

		if(pad&PAD_LEFT)  if(sprite_x>4)   sprite_x-=2;
		if(pad&PAD_RIGHT) if(sprite_x<252) sprite_x+=2;
		if(pad&PAD_UP)    if(sprite_y>4)   sprite_y-=2;
		if(pad&PAD_DOWN)  if(sprite_y<236) sprite_y+=2;
	}
}
